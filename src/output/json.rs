use crate::{
    alloc::{AllocOp, AllocOpMap, AllocTally},
    counter::KnownCounterKind,
    stats::{Stats, StatsSet},
};

use super::{LeafStat, OutputStats, StatTree};
use serde_json::{json, Value as JsonValue};

fn trans_alloc_tallies(m: &AllocOpMap<AllocTally<StatsSet<f64>>>) -> JsonValue {
    JsonValue::Object(
        AllocOp::ALL
            .iter()
            .map(|op| {
                let tally = m.get(*op);
                (
                    op.name().to_owned(),
                    json!({
                        "count" : trans_statset(&tally.count, |c| c as usize),
                        "size" : trans_statset(&tally.size, |c| c as usize),
                    }),
                )
            })
            .collect(),
    )
}

fn trans_counters(counts: &Stats) -> JsonValue {
    JsonValue::Object(
        KnownCounterKind::ALL
            .iter()
            .map(|c| {
                let stats = counts.get_counts(*c);
                (
                    match c {
                        KnownCounterKind::Bytes => "bytes",
                        KnownCounterKind::Chars => "chars",
                        KnownCounterKind::Items => "items",
                    }
                    .to_owned(),
                    stats.map_or(JsonValue::Null, |s| trans_statset(s, |c| c as usize)),
                )
            })
            .collect(),
    )
}

fn trans_statset<T: Copy>(s: &StatsSet<T>, intrep: impl Fn(T) -> usize) -> JsonValue {
    json!({
        "fastest": intrep(s.fastest),
        "slowest": intrep(s.slowest),
        "median": intrep(s.median),
        "mean": intrep(s.mean),
    })
}

fn trans_leaf(ls: LeafStat) -> JsonValue {
    match ls {
        LeafStat::Ignored => json!("Ignored"),
        LeafStat::Empty => json!("Empty"),
        LeafStat::Benched { stats, bytes_format: _ } => {
            let s = *stats;
            json!(
                {
                    "sample_count": format!("{}", s.sample_count),
                    "iter_count": format!("{}", s.iter_count),
                    "time": trans_statset(&s.time, |f| f.picos as usize),
                    "alloc_tallies" : trans_alloc_tallies(&s.alloc_tallies),
                    "counters" : trans_counters(&s)
                }
            )
        }
    }
}

fn trans_stattree_nested(value: StatTree) -> (String, JsonValue) {
    match value {
        StatTree::Parent { name, children } => {
            (name, JsonValue::Object(children.into_iter().map(trans_stattree_nested).collect()))
        }
        StatTree::Leaf { name, result } => (name, trans_leaf(result)),
    }
}

/// Create a nested/tree output of the [StatTree] in json format.
pub(crate) fn json_output(
    OutputStats { tree, precision }: OutputStats,
    mut out: impl std::io::prelude::Write,
) -> std::io::Result<()> {
    let benchmark_results: JsonValue =
        JsonValue::Object(tree.into_iter().map(trans_stattree_nested).collect());
    let output = serde_json::to_string(&json!(
        {
            "description" : "Generated by Divan: Time is in picoseconds.",
            "precision" : precision,
            "benchmarks" : benchmark_results,
        }
    ))?;
    writeln!(out, "{}", output)
}

fn trans_stattree_flat(names: &mut Vec<String>, st: StatTree, out: &mut Vec<JsonValue>) {
    match st {
        StatTree::Parent { name, children } => {
            names.push(name);
            for child in children {
                trans_stattree_flat(names, child, out);
            }
            names.pop();
        }
        StatTree::Leaf { name, result } => {
            names.push(name);
            let path = names.clone();
            names.pop();

            if matches!(result, LeafStat::Benched { .. }) {
                out.push(json!({
                    "path": path,
                    "result": trans_leaf(result)
                }));
            }
        }
    }
}

/// Create a flat output of the [StatTree] in json format.
/// - Empty or ignored benchmarks are not included, unlike [json_output].
pub(crate) fn json_flat_output(
    OutputStats { tree, precision }: OutputStats,
    mut out: impl std::io::prelude::Write,
) -> std::io::Result<()> {
    let mut stat_elements = Vec::new();
    for st in tree {
        trans_stattree_flat(&mut Vec::new(), st, &mut stat_elements);
    }
    let output = serde_json::to_string(&json!(
        {
            "description" : "Generated by Divan: Time is in picoseconds, only benchmarks with results (not empty or ignored) are present.",
            "precision" : precision,
            "benchmarks" : stat_elements,
        }
    ))?;
    writeln!(out, "{}", output)
}
